{"name":"Gc","tagline":"The Boehm-Demers-Weiser conservative C/C++ Garbage Collector (libgc, bdwgc, boehmgc) ","body":"# Boehm-Demers-Weiser Garbage Collector\r\n\r\nThis is version 7.3alpha3 of a conservative garbage collector for C and C++.\r\n\r\nYou might find a more recent version\r\n[here](http://www.hpl.hp.com/personal/Hans_Boehm/gc).\r\n\r\n## Overview\r\n\r\nThis is intended to be a general purpose, garbage collecting storage\r\nallocator.  The algorithms used are described in:\r\n\r\n * Boehm, H., and M. Weiser, \"Garbage Collection in an Uncooperative\r\n   Environment\", Software Practice & Experience, September 1988, pp. 807-820.\r\n\r\n * Boehm, H., A. Demers, and S. Shenker, \"Mostly Parallel Garbage Collection\",\r\n   Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design\r\n   and Implementation, SIGPLAN Notices 26, 6 (June 1991), pp. 157-164.\r\n\r\n * Boehm, H., \"Space Efficient Conservative Garbage Collection\", Proceedings\r\n   of the ACM SIGPLAN '91 Conference on Programming Language Design and\r\n   Implementation, SIGPLAN Notices 28, 6 (June 1993), pp. 197-206.\r\n\r\n * Boehm H., \"Reducing Garbage Collector Cache Misses\", Proceedings of the\r\n   2000 International Symposium on Memory Management.\r\n\r\nPossible interactions between the collector and optimizing compilers are\r\ndiscussed in\r\n\r\n * Boehm, H., and D. Chase, \"A Proposal for GC-safe C Compilation\",\r\n   The Journal of C Language Translation 4, 2 (December 1992).\r\n\r\nand\r\n\r\n * Boehm H., \"Simple GC-safe Compilation\", Proceedings of the ACM SIGPLAN '96\r\n   Conference on Programming Language Design and Implementation.\r\n\r\n(Some of these are also available from\r\n[here](http://www.hpl.hp.com/personal/Hans_Boehm/papers/), among other places.)\r\n\r\nUnlike the collector described in the second reference, this collector\r\noperates either with the mutator stopped during the entire collection\r\n(default) or incrementally during allocations.  (The latter is supported\r\non fewer machines.)  On the most common platforms, it can be built\r\nwith or without thread support.  On a few platforms, it can take advantage\r\nof a multiprocessor to speed up garbage collection.\r\n\r\nMany of the ideas underlying the collector have previously been explored\r\nby others.  Notably, some of the run-time systems developed at Xerox PARC\r\nin the early 1980s conservatively scanned thread stacks to locate possible\r\npointers (cf. Paul Rovner, \"On Adding Garbage Collection and Runtime Types\r\nto a Strongly-Typed Statically Checked, Concurrent Language\"  Xerox PARC\r\nCSL 84-7).  Doug McIlroy wrote a simpler fully conservative collector that\r\nwas part of version 8 UNIX (tm), but appears to not have received\r\nwidespread use.\r\n\r\nRudimentary tools for use of the collector as a leak detector are included\r\n([link](http://www.hpl.hp.com/personal/Hans_Boehm/gc/leak.html)),\r\nas is a fairly sophisticated string package \"cord\" that makes use of the\r\ncollector.  (See doc/README.cords and H.-J. Boehm, R. Atkinson, and M. Plass,\r\n\"Ropes: An Alternative to Strings\", Software Practice and Experience 25, 12\r\n(December 1995), pp. 1315-1330.  This is very similar to the \"rope\" package\r\nin Xerox Cedar, or the \"rope\" package in the SGI STL or the g++ distribution.)\r\n\r\nFurther collector documentation can be found\r\n[here](http://www.hpl.hp.com/personal/Hans_Boehm/gc).\r\n\r\n\r\n## General Description\r\n\r\nThis is a garbage collecting storage allocator that is intended to be\r\nused as a plug-in replacement for C's malloc.\r\n\r\nSince the collector does not require pointers to be tagged, it does not\r\nattempt to ensure that all inaccessible storage is reclaimed.  However,\r\nin our experience, it is typically more successful at reclaiming unused\r\nmemory than most C programs using explicit deallocation.  Unlike manually\r\nintroduced leaks, the amount of unreclaimed memory typically stays\r\nbounded.\r\n\r\nIn the following, an \"object\" is defined to be a region of memory allocated\r\nby the routines described below.\r\n\r\nAny objects not intended to be collected must be pointed to either\r\nfrom other such accessible objects, or from the registers,\r\nstack, data, or statically allocated bss segments.  Pointers from\r\nthe stack or registers may point to anywhere inside an object.\r\nThe same is true for heap pointers if the collector is compiled with\r\n`ALL_INTERIOR_POINTERS` defined, or `GC_all_interior_pointers` is otherwise\r\nset, as is now the default.\r\n\r\nCompiling without `ALL_INTERIOR_POINTERS` may reduce accidental retention\r\nof garbage objects, by requiring pointers from the heap to the beginning\r\nof an object.  But this no longer appears to be a significant\r\nissue for most programs occupying a small fraction of the possible\r\naddress space.\r\n\r\nThere are a number of routines which modify the pointer recognition\r\nalgorithm.  `GC_register_displacement` allows certain interior pointers\r\nto be recognized even if `ALL_INTERIOR_POINTERS` is nor defined.\r\n`GC_malloc_ignore_off_page` allows some pointers into the middle of\r\nlarge objects to be disregarded, greatly reducing the probability of\r\naccidental retention of large objects.  For most purposes it seems\r\nbest to compile with `ALL_INTERIOR_POINTERS` and to use\r\n`GC_malloc_ignore_off_page` if you get collector warnings from\r\nallocations of very large objects.  See doc/debugging.html for details.\r\n\r\n_WARNING_: pointers inside memory allocated by the standard `malloc` are not\r\nseen by the garbage collector.  Thus objects pointed to only from such a\r\nregion may be prematurely deallocated.  It is thus suggested that the\r\nstandard `malloc` be used only for memory regions, such as I/O buffers, that\r\nare guaranteed not to contain pointers to garbage collectable memory.\r\nPointers in C language automatic, static, or register variables,\r\nare correctly recognized.  (Note that `GC_malloc_uncollectable` has\r\nsemantics similar to standard malloc, but allocates objects that are\r\ntraced by the collector.)\r\n\r\n_WARNING_: the collector does not always know how to find pointers in data\r\nareas that are associated with dynamic libraries.  This is easy to\r\nremedy IF you know how to find those data areas on your operating\r\nsystem (see `GC_add_roots`).  Code for doing this under SunOS, IRIX\r\n5.X and 6.X, HP/UX, Alpha OSF/1, Linux, and win32 is included and used\r\nby default.  (See doc/README.win32 for Win32 details.)  On other systems\r\npointers from dynamic library data areas may not be considered by the\r\ncollector.  If you're writing a program that depends on the collector\r\nscanning dynamic library data areas, it may be a good idea to include\r\nat least one call to `GC_is_visible` to ensure that those areas are\r\nvisible to the collector.\r\n\r\nNote that the garbage collector does not need to be informed of shared\r\nread-only data.  However if the shared library mechanism can introduce\r\ndiscontiguous data areas that may contain pointers, then the collector does\r\nneed to be informed.\r\n\r\nSignal processing for most signals may be deferred during collection,\r\nand during uninterruptible parts of the allocation process.\r\nLike standard ANSI C mallocs, by default it is unsafe to invoke\r\nmalloc (and other GC routines) from a signal handler while another\r\nmalloc call may be in progress.\r\n\r\nThe allocator/collector can also be configured for thread-safe operation.\r\n(Full signal safety can also be achieved, but only at the cost of two system\r\ncalls per malloc, which is usually unacceptable.)\r\n\r\n_WARNING_: the collector does not guarantee to scan thread-local storage\r\n(e.g. of the kind accessed with `pthread_getspecific`).  The collector\r\ndoes scan thread stacks, though, so generally the best solution is to\r\nensure that any pointers stored in thread-local storage are also\r\nstored on the thread's stack for the duration of their lifetime.\r\n(This is arguably a longstanding bug, but it hasn't been fixed yet.)\r\n\r\n## Installation and Portability\r\n\r\nAs distributed, the collector operates silently\r\nIn the event of problems, this can usually be changed by defining the\r\n`GC_PRINT_STATS` or `GC_PRINT_VERBOSE_STATS` environment variables.  This\r\nwill result in a few lines of descriptive output for each collection.\r\n(The given statistics exhibit a few peculiarities.\r\nThings don't appear to add up for a variety of reasons, most notably\r\nfragmentation losses.  These are probably much more significant for the\r\ncontrived program \"test.c\" than for your application.)\r\n\r\nOn most Unix-like platforms, the collector can be built either using a\r\nGNU autoconf-based build infrastructure (type `configure; make` in the\r\nsimplest case), or with a classic makefile by itself (type\r\n`make -f Makefile.direct`).  Here we focus on the latter option.\r\nOn other platforms, typically only the latter option is available, though\r\nwith a different supplied Makefile.)\r\n\r\nFor the Makefile.direct-based process, typing `make test` instead of `make`\r\nwill automatically build the collector and then run `setjmp_test` and `gctest`.\r\n`Setjmp_test` will give you information about configuring the collector, which is\r\nuseful primarily if you have a machine that's not already supported.  Gctest is\r\na somewhat superficial test of collector functionality.  Failure is indicated\r\nby a core dump or a message to the effect that the collector is broken.  Gctest\r\ntakes about a second to two to run on reasonable 2007 vintage desktops.  It may\r\nuse up to about 30MB of memory.  (The multi-threaded version will use more.\r\n64-bit versions may use more.) `make test` will also, as its last step, attempt\r\nto build and test the \"cord\" string library.)\r\n\r\nMakefile.direct will generate a library gc.a which you should link against.\r\nTyping \"make cords\" will add the cord library to gc.a.\r\n\r\nThe GNU style build process understands the usual targets.  `make check`\r\nruns a number of tests.  `make install` installs at least libgc, and libcord.\r\nTry `./configure --help` to see the configuration options.  It is currently\r\nnot possible to exercise all combinations of build options this way.\r\n\r\nIt is suggested that if you need to replace a piece of the collector\r\n(e.g. GC_mark_rts.c) you simply list your version ahead of gc.a on the\r\nld command line, rather than replacing the one in gc.a.  (This will\r\ngenerate numerous warnings under some versions of AIX, but it still\r\nworks.)\r\n\r\nAll include files that need to be used by clients will be put in the\r\ninclude subdirectory.  (Normally this is just gc.h.  `make cords` adds\r\n\"cord.h\" and \"ec.h\".)\r\n\r\nThe collector currently is designed to run essentially unmodified on\r\nmachines that use a flat 32-bit or 64-bit address space.\r\nThat includes the vast majority of Workstations and X86 (X >= 3) PCs.\r\n(The list here was deleted because it was getting too long and constantly\r\nout of date.)\r\n\r\nIn a few cases (Amiga, OS/2, Win32, MacOS) a separate makefile\r\nor equivalent is supplied.  Many of these have separate README.system\r\nfiles.\r\n\r\nDynamic libraries are completely supported only under SunOS/Solaris,\r\n(and even that support is not functional on the last Sun 3 release),\r\nLinux, FreeBSD, NetBSD, IRIX 5&6, HP/UX, Win32 (not Win32S) and OSF/1\r\non DEC AXP machines plus perhaps a few others listed near the top\r\nof dyn_load.c.  On other machines we recommend that you do one of\r\nthe following:\r\n\r\n 1) Add dynamic library support (and send us the code).\r\n 2) Use static versions of the libraries.\r\n 3) Arrange for dynamic libraries to use the standard malloc.\r\n    This is still dangerous if the library stores a pointer to a\r\n    garbage collected object.  But nearly all standard interfaces\r\n    prohibit this, because they deal correctly with pointers\r\n    to stack allocated objects.  (Strtok is an exception.  Don't\r\n    use it.)\r\n\r\nIn all cases we assume that pointer alignment is consistent with that\r\nenforced by the standard C compilers.  If you use a nonstandard compiler\r\nyou may have to adjust the alignment parameters defined in gc_priv.h.\r\nNote that this may also be an issue with packed records/structs, if those\r\nenforce less alignment for pointers.\r\n\r\nA port to a machine that is not byte addressed, or does not use 32 bit\r\nor 64 bit addresses will require a major effort.  A port to plain MSDOS\r\nor win16 is hard.\r\n\r\nFor machines not already mentioned, or for nonstandard compilers,\r\nsome porting suggestions are provided in doc/porting.html.\r\n\r\n## The C Interface to the Allocator\r\n\r\nThe following routines are intended to be directly called by the user.\r\nNote that usually only `GC_malloc` is necessary.  `GC_clear_roots` and\r\n`GC_add_roots` calls may be required if the collector has to trace\r\nfrom nonstandard places (e.g. from dynamic library data areas on a\r\nmachine on which the collector doesn't already understand them.)  On\r\nsome machines, it may be desirable to set `GC_stacktop` to a good\r\napproximation of the stack base.  (This enhances code portability on\r\nHP PA machines, since there is no good way for the collector to\r\ncompute this value.)  Client code may include \"gc.h\", which defines\r\nall of the following, plus many others.\r\n\r\n 1) `GC_malloc(nbytes)`\r\n    - Allocate an object of size nbytes.  Unlike malloc, the object is\r\n      cleared before being returned to the user.  `GC_malloc` will\r\n      invoke the garbage collector when it determines this to be appropriate.\r\n      GC_malloc may return 0 if it is unable to acquire sufficient\r\n      space from the operating system.  This is the most probable\r\n      consequence of running out of space.  Other possible consequences\r\n      are that a function call will fail due to lack of stack space,\r\n      or that the collector will fail in other ways because it cannot\r\n      maintain its internal data structures, or that a crucial system\r\n      process will fail and take down the machine.  Most of these\r\n      possibilities are independent of the malloc implementation.\r\n\r\n 2) `GC_malloc_atomic(nbytes)`\r\n     - Allocate an object of size nbytes that is guaranteed not to contain any\r\n       pointers.  The returned object is not guaranteed to be cleared.\r\n       (Can always be replaced by `GC_malloc`, but results in faster collection\r\n       times.  The collector will probably run faster if large character\r\n       arrays, etc. are allocated with `GC_malloc_atomic` than if they are\r\n       statically allocated.)\r\n\r\n 3) `GC_realloc(object, new_size)`\r\n    - Change the size of object to be `new_size`.  Returns a pointer to the\r\n      new object, which may, or may not, be the same as the pointer to\r\n      the old object.  The new object is taken to be atomic if and only if the\r\n      old one was.  If the new object is composite and larger than the original\r\n      object,then the newly added bytes are cleared (we hope).  This is very\r\n      likely to allocate a new object, unless `MERGE_SIZES` is defined in\r\n      gc_priv.h.  Even then, it is likely to recycle the old object only if the\r\n      object is grown in small additive increments (which, we claim, is\r\n      generally bad coding practice.)\r\n\r\n 4) `GC_free(object)`\r\n    - Explicitly deallocate an object returned by `GC_malloc` or\r\n      `GC_malloc_atomic`.  Not necessary, but can be used to minimize\r\n      collections if performance is critical.  Probably a performance\r\n      loss for very small objects (<= 8 bytes).\r\n\r\n 5) `GC_expand_hp(bytes)`\r\n     - Explicitly increase the heap size.  (This is normally done automatically\r\n       if a garbage collection failed to `GC_reclaim` enough memory.  Explicit\r\n       calls to `GC_expand_hp` may prevent unnecessarily frequent collections at\r\n       program startup.)\r\n\r\n 6) `GC_malloc_ignore_off_page(bytes)`\r\n     - Identical to `GC_malloc`, but the client promises to keep a pointer to\r\n       the somewhere within the first 256 bytes of the object while it is\r\n       live.  (This pointer should normally be declared volatile to prevent\r\n       interference from compiler optimizations.)  This is the recommended\r\n       way to allocate anything that is likely to be larger than 100 Kbytes\r\n       or so.  (`GC_malloc` may result in failure to reclaim such objects.)\r\n\r\n 7) `GC_set_warn_proc(proc)`\r\n     - Can be used to redirect warnings from the collector.  Such warnings\r\n       should be rare, and should not be ignored during code development.\r\n\r\n 8) `GC_enable_incremental()`\r\n     - Enables generational and incremental collection.  Useful for large\r\n       heaps on machines that provide access to page dirty information.\r\n       Some dirty bit implementations may interfere with debugging\r\n       (by catching address faults) and place restrictions on heap arguments\r\n       to system calls (since write faults inside a system call may not be\r\n       handled well).\r\n\r\n 9) Several routines to allow for registration of finalization code.\r\n    User supplied finalization code may be invoked when an object becomes\r\n    unreachable.  To call `(*f)(obj, x)` when obj becomes inaccessible, use\r\n    `GC_register_finalizer(obj, f, x, 0, 0);`\r\n    For more sophisticated uses, and for finalization ordering issues,\r\n    see gc.h.\r\n\r\nThe global variable `GC_free_space_divisor` may be adjusted up from it\r\ndefault value of 3 to use less space and more collection time, or down for\r\nthe opposite effect.  Setting it to 1 will almost disable collections\r\nand cause all allocations to simply grow the heap.\r\n\r\nThe variable `GC_non_gc_bytes`, which is normally 0, may be changed to reflect\r\nthe amount of memory allocated by the above routines that should not be\r\nconsidered as a candidate for collection.  Careless use may, of course, result\r\nin excessive memory consumption.\r\n\r\nSome additional tuning is possible through the parameters defined\r\nnear the top of gc_priv.h.\r\n\r\nIf only `GC_malloc` is intended to be used, it might be appropriate to define:\r\n\r\n    #define malloc(n) GC_malloc(n)\r\n    #define calloc(m,n) GC_malloc((m)*(n))\r\n\r\nFor small pieces of VERY allocation intensive code, gc_inl.h includes\r\nsome allocation macros that may be used in place of `GC_malloc` and\r\nfriends.\r\n\r\nAll externally visible names in the garbage collector start with `GC_`.\r\nTo avoid name conflicts, client code should avoid this prefix, except when\r\naccessing garbage collector routines or variables.\r\n\r\nThere are provisions for allocation with explicit type information.\r\nThis is rarely necessary.  Details can be found in gc_typed.h.\r\n\r\n## The C++ Interface to the Allocator\r\n\r\nThe Ellis-Hull C++ interface to the collector is included in\r\nthe collector distribution.  If you intend to use this, type\r\n`make c++` after the initial build of the collector is complete.\r\nSee gc_cpp.h for the definition of the interface.  This interface\r\ntries to approximate the Ellis-Detlefs C++ garbage collection\r\nproposal without compiler changes.\r\n\r\nVery often it will also be necessary to use gc_allocator.h and the\r\nallocator declared there to construct STL data structures.  Otherwise\r\nsubobjects of STL data structures will be allocated using a system\r\nallocator, and objects they refer to may be prematurely collected.\r\n\r\n## Use as Leak Detector\r\n\r\nThe collector may be used to track down leaks in C programs that are\r\nintended to run with malloc/free (e.g. code with extreme real-time or\r\nportability constraints).  To do so define `FIND_LEAK` in Makefile.\r\nThis will cause the collector to invoke the `report_leak`\r\nroutine defined near the top of reclaim.c whenever an inaccessible\r\nobject is found that has not been explicitly freed.  Such objects will\r\nalso be automatically reclaimed.\r\n\r\nIf all objects are allocated with `GC_DEBUG_MALLOC` (see next section), then\r\nthe default version of report_leak will report at least the source file and\r\nline number at which the leaked object was allocated.  This may sometimes be\r\nsufficient.  (On a few machines, it will also report a cryptic stack trace.\r\nIf this is not symbolic, it can sometimes be called into a symbolic stack\r\ntrace by invoking program \"foo\" with \"tools/callprocs.sh foo\".  It is a short\r\nshell script that invokes adb to expand program counter values to symbolic\r\naddresses.  It was largely supplied by Scott Schwartz.)\r\n\r\nNote that the debugging facilities described in the next section can\r\nsometimes be slightly LESS effective in leak finding mode, since in\r\nleak finding mode, `GC_debug_free` actually results in reuse of the object.\r\n(Otherwise the object is simply marked invalid.)  Also note that the test\r\nprogram is not designed to run meaningfully in `FIND_LEAK` mode.\r\nUse \"make gc.a\" to build the collector.\r\n\r\n## Debugging Facilities\r\n\r\nThe routines `GC_debug_malloc`, `GC_debug_malloc_atomic`, `GC_debug_realloc`,\r\nand `GC_debug_free` provide an alternate interface to the collector, which\r\nprovides some help with memory overwrite errors, and the like.\r\nObjects allocated in this way are annotated with additional\r\ninformation.  Some of this information is checked during garbage\r\ncollections, and detected inconsistencies are reported to stderr.\r\n\r\nSimple cases of writing past the end of an allocated object should\r\nbe caught if the object is explicitly deallocated, or if the\r\ncollector is invoked while the object is live.  The first deallocation\r\nof an object will clear the debugging info associated with an\r\nobject, so accidentally repeated calls to `GC_debug_free` will report the\r\ndeallocation of an object without debugging information.  Out of\r\nmemory errors will be reported to stderr, in addition to returning `NULL`.\r\n\r\n`GC_debug_malloc` checking  during garbage collection is enabled\r\nwith the first call to `GC_debug_malloc`.  This will result in some\r\nslowdown during collections.  If frequent heap checks are desired,\r\nthis can be achieved by explicitly invoking `GC_gcollect`, e.g. from\r\nthe debugger.\r\n\r\n`GC_debug_malloc` allocated objects should not be passed to `GC_realloc`\r\nor `GC_free`, and conversely.  It is however acceptable to allocate only\r\nsome objects with `GC_debug_malloc`, and to use `GC_malloc` for other objects,\r\nprovided the two pools are kept distinct.  In this case, there is a very\r\nlow probability that `GC_malloc` allocated objects may be misidentified as\r\nhaving been overwritten.  This should happen with probability at most\r\none in 2**32.  This probability is zero if `GC_debug_malloc` is never called.\r\n\r\n`GC_debug_malloc`, `GC_malloc_atomic`, and `GC_debug_realloc` take two\r\nadditional trailing arguments, a string and an integer.  These are not\r\ninterpreted by the allocator.  They are stored in the object (the string is\r\nnot copied).  If an error involving the object is detected, they are printed.\r\n\r\nThe macros `GC_MALLOC`, `GC_MALLOC_ATOMIC`, `GC_REALLOC`, `GC_FREE`, and\r\n`GC_REGISTER_FINALIZER` are also provided.  These require the same arguments\r\nas the corresponding (nondebugging) routines.  If gc.h is included\r\nwith `GC_DEBUG` defined, they call the debugging versions of these\r\nfunctions, passing the current file name and line number as the two\r\nextra arguments, where appropriate.  If gc.h is included without `GC_DEBUG`\r\ndefined, then all these macros will instead be defined to their nondebugging\r\nequivalents.  (`GC_REGISTER_FINALIZER` is necessary, since pointers to\r\nobjects with debugging information are really pointers to a displacement\r\nof 16 bytes form the object beginning, and some translation is necessary\r\nwhen finalization routines are invoked.  For details, about what's stored\r\nin the header, see the definition of the type oh in debug_malloc.c)\r\n\r\n## Incremental/Generational Collection\r\n\r\nThe collector normally interrupts client code for the duration of\r\na garbage collection mark phase.  This may be unacceptable if interactive\r\nresponse is needed for programs with large heaps.  The collector\r\ncan also run in a \"generational\" mode, in which it usually attempts to\r\ncollect only objects allocated since the last garbage collection.\r\nFurthermore, in this mode, garbage collections run mostly incrementally,\r\nwith a small amount of work performed in response to each of a large number of\r\n`GC_malloc` requests.\r\n\r\nThis mode is enabled by a call to `GC_enable_incremental`.\r\n\r\nIncremental and generational collection is effective in reducing\r\npause times only if the collector has some way to tell which objects\r\nor pages have been recently modified.  The collector uses two sources\r\nof information:\r\n\r\n1. Information provided by the VM system.  This may be provided in\r\n   one of several forms.  Under Solaris 2.X (and potentially under other\r\n   similar systems) information on dirty pages can be read from the\r\n   /proc file system.  Under other systems (currently SunOS4.X) it is\r\n   possible to write-protect the heap, and catch the resulting faults.\r\n   On these systems we require that system calls writing to the heap\r\n   (other than read) be handled specially by client code.\r\n   See os_dep.c for details.\r\n\r\n2. Information supplied by the programmer.  We define \"stubborn\"\r\n   objects to be objects that are rarely changed.  Such an object\r\n   can be allocated (and enabled for writing) with `GC_malloc_stubborn`.\r\n   Once it has been initialized, the collector should be informed with\r\n   a call to `GC_end_stubborn_change`.  Subsequent writes that store\r\n   pointers into the object must be preceded by a call to\r\n   `GC_change_stubborn`.\r\n\r\nThis mechanism performs best for objects that are written only for\r\ninitialization, and such that only one stubborn object is writable\r\nat once.  It is typically not worth using for short-lived\r\nobjects.  Stubborn objects are treated less efficiently than pointerfree\r\n(atomic) objects.\r\n\r\nA rough rule of thumb is that, in the absence of VM information, garbage\r\ncollection pauses are proportional to the amount of pointerful storage\r\nplus the amount of modified \"stubborn\" storage that is reachable during\r\nthe collection.\r\n\r\nInitial allocation of stubborn objects takes longer than allocation\r\nof other objects, since other data structures need to be maintained.\r\n\r\nWe recommend against random use of stubborn objects in client\r\ncode, since bugs caused by inappropriate writes to stubborn objects\r\nare likely to be very infrequently observed and hard to trace.\r\nHowever, their use may be appropriate in a few carefully written\r\nlibrary routines that do not make the objects themselves available\r\nfor writing by client code.\r\n\r\n\r\n## Bugs\r\n\r\nAny memory that does not have a recognizable pointer to it will be\r\nreclaimed.  Exclusive-or'ing forward and backward links in a list\r\ndoesn't cut it.\r\n\r\nSome C optimizers may lose the last undisguised pointer to a memory\r\nobject as a consequence of clever optimizations.  This has almost\r\nnever been observed in practice.\r\n\r\nThis is not a real-time collector.  In the standard configuration,\r\npercentage of time required for collection should be constant across\r\nheap sizes.  But collection pauses will increase for larger heaps.\r\nThey will decrease with the number of processors if parallel marking\r\nis enabled.\r\n\r\n(On 2007 vintage machines, GC times may be on the order of 5 msecs\r\nper MB of accessible memory that needs to be scanned and processor.\r\nYour mileage may vary.)  The incremental/generational collection facility\r\nmay help in some cases.\r\n\r\nPlease address bug reports [here](mailto:gc@linux.hpl.hp.com).  If you are\r\ncontemplating a major addition, you might also send mail to ask whether\r\nit's already been done (or whether we tried and discarded it).\r\n\r\n## Copyright & Warranty\r\n\r\n * Copyright (c) 1988, 1989 Hans-J. Boehm, Alan J. Demers\r\n * Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\r\n * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\r\n * Copyright (c) 1999-2011 by Hewlett-Packard Development Company.\r\n\r\nThe file linux_threads.c is also\r\n\r\n * Copyright (c) 1998 by Fergus Henderson.  All rights reserved.\r\n\r\nThe files Makefile.am, and configure.in are\r\n\r\n* Copyright (c) 2001 by Red Hat Inc. All rights reserved.\r\n\r\nSeveral files supporting GNU-style builds are copyrighted by the Free\r\nSoftware Foundation, and carry a different license from that given\r\nbelow.  The files included in the libatomic_ops distribution (included\r\nhere) use either the license below, or a similar MIT-style license,\r\nor, for some files not actually used by the garbage-collector library, the\r\nGPL.\r\n\r\nTHIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\r\nOR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\r\n\r\nPermission is hereby granted to use or copy this program\r\nfor any purpose,  provided the above notices are retained on all copies.\r\nPermission to modify the code and to distribute modified code is granted,\r\nprovided the above notices are retained, and a notice that the code was\r\nmodified is included with the above copyright notice.\r\n\r\nA few of the files needed to use the GNU-style build procedure come with\r\nslightly different licenses, though they are all similar in spirit.  A few\r\nare GPL'ed, but with an exception that should cover all uses in the\r\ncollector. (If you are concerned about such things, I recommend you look\r\nat the notice in config.guess or ltmain.sh.)\r\n\r\nThe atomic_ops library contains some code that is covered by the GNU General\r\nPublic License, but is not needed by, nor linked into the collector library.\r\nIt is included here only because the atomic_ops distribution is, for\r\nsimplicity, included in its entirety.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}